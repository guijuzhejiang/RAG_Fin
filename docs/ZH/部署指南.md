# RAG API 部署和使用指南

## 📋 项目概述

一个FastAPI版本的RAG核心API，具备以下特点：

✅ **功能简化**: 只包含RAG核心功能，去除了用户认证、管理端等复杂功能  
✅ **技术栈现代化**: 使用FastAPI替代Flask，提供更好的性能和自动文档  
✅ **数据库云端化**: 使用Supabase作为PostgreSQL数据库，支持向量搜索  
✅ **配置管理**: 使用.env文件管理环境变量  
✅ **自动建表**: 提供SQL脚本在Supabase中创建所有必要的表  

## 🎯 核心功能模块

### 1. 知识库操作 (Knowledge Base)
- 创建、更新、删除知识库
- 配置向量模型和分块参数
- 知识库统计和搜索

### 2. 文档管理 (Document)
- 文档上传和内容管理
- 支持多种文件格式解析
- 文档处理状态跟踪

### 3. 块管理 (Chunk)
- 文档分块和向量化
- 向量搜索和相似度匹配
- 块内容管理

### 4. 对话系统 (Conversation)
- RAG增强的智能问答
- 对话历史管理
- 上下文感知回复

### 5. 文件管理 (File)
- 通用文件上传和存储
- 文件信息管理
- 文件下载和删除

## 🚀 快速部署

### 第一步：环境准备

1. **Python环境**
```bash
# 确保Python 3.8+
python --version

# 安装依赖
cd vdr_service
pip install -r requirements.txt
```

2. **Supabase配置**
```bash
# 复制环境变量模板
cp env_example.txt .env

# 编辑.env文件，填入你的Supabase信息
SUPABASE_URL=https://hwdvevrpvawsotijgsfx.supabase.co
SUPABASE_KEY=eyJhxxx
```

### 第二步：数据库建表

#### 方案1：通过API获取SQL（推荐）
```bash
# 启动API服务
python start.py

# 访问建表SQL端点
curl http://localhost:8000/setup/sql
```

#### 方案2：直接使用SQL文件
```sql
-- 在Supabase SQL Editor中执行 create_tables.sql 中的内容
```

### 第三步：启动服务

```bash
# 使用简化启动脚本
python start.py

# 或者使用uvicorn直接启动
python -m uvicorn main:app --host 127.0.0.1 --port 8000 --reload
```

### 第四步：验证部署

访问以下地址确认服务正常：
- API根路径: http://localhost:8000/
- Swagger文档: http://localhost:8000/docs
- ReDoc文档: http://localhost:8000/redoc
- 健康检查: http://localhost:8000/health

## 🗄️ Supabase表创建详解

### 是否需要手动创建表？

**建议使用SQL脚本自动创建**，我提供了两种方式：

#### 方式1：在Supabase Dashboard中执行SQL

1. 登录你的Supabase项目
2. 进入 **SQL Editor**
3. 复制 `create_tables.sql` 文件内容
4. 点击 **Run** 执行

#### 方式2：通过API端点获取SQL

启动API后访问：`http://localhost:8000/setup/sql`

### 核心表结构

```sql
-- 1. 知识库表
CREATE TABLE knowledge_bases (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    embedding_model VARCHAR(100) DEFAULT 'text-embedding-3-small',
    chunk_size INTEGER DEFAULT 1000,
    chunk_overlap INTEGER DEFAULT 200,
    similarity_threshold FLOAT DEFAULT 0.7,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 2. 文档表
CREATE TABLE documents (
    id UUID PRIMARY KEY,
    kb_id UUID REFERENCES knowledge_bases(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    file_type VARCHAR(50),
    file_size BIGINT,
    content TEXT,
    metadata JSONB DEFAULT '{}',
    status VARCHAR(50) DEFAULT 'pending',
    progress FLOAT DEFAULT 0.0,
    error_message TEXT,
    chunk_count INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 3. 块表（支持向量搜索）
CREATE TABLE chunks (
    id UUID PRIMARY KEY,
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    kb_id UUID REFERENCES knowledge_bases(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    metadata JSONB DEFAULT '{}',
    embedding VECTOR(1536), -- pgvector扩展
    position_in_doc INTEGER,
    chunk_size INTEGER,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 4. 对话表
CREATE TABLE conversations (
    id UUID PRIMARY KEY,
    title VARCHAR(255) DEFAULT 'New Conversation',
    kb_ids UUID[] DEFAULT '{}',
    system_prompt TEXT,
    temperature FLOAT DEFAULT 0.7,
    max_tokens INTEGER DEFAULT 2000,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 5. 对话消息表
CREATE TABLE conversation_messages (
    id UUID PRIMARY KEY,
    conversation_id UUID REFERENCES conversations(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL,
    content TEXT NOT NULL,
    metadata JSONB DEFAULT '{}',
    context_chunks UUID[] DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 6. 文件表
CREATE TABLE files (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    original_name VARCHAR(255) NOT NULL,
    file_type VARCHAR(50),
    file_size BIGINT,
    storage_path VARCHAR(500),
    mime_type VARCHAR(100),
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### 重要：启用pgvector扩展

**必须先启用pgvector扩展才能支持向量搜索：**

```sql
-- 在所有表创建之前执行
CREATE EXTENSION IF NOT EXISTS vector;
```

## 🔧 配置详解

### 环境变量配置

```env
# Supabase数据库配置
SUPABASE_URL=https://hwdvevrpvawsotijgsfx.supabase.co
SUPABASE_KEY=xxxxxx  # 你的API Key

# API服务配置
API_HOST=0.0.0.0
API_PORT=8000
DEBUG=True

# 向量搜索配置
EMBEDDING_MODEL=text-embedding-3-small
EMBEDDING_DIMENSION=1536

# 文件上传配置
MAX_FILE_SIZE=100MB
ALLOWED_FILE_TYPES=pdf,doc,docx,txt,md,ppt,pptx,xls,xlsx

# LLM配置（可选，用于未来扩展）
OPENAI_API_KEY=your_openai_key_here
DEFAULT_LLM_MODEL=gpt-3.5-turbo
```

### Supabase项目配置

1. **获取项目URL和API Key**
   - 登录Supabase Dashboard
   - 进入项目设置 → API
   - 复制 Project URL 和 anon public key

2. **启用必要功能**
   - 确保启用了Row Level Security (RLS)
   - 启用pgvector扩展（用于向量搜索）

## 📝 API使用示例

### 基础工作流程

```python
import requests

BASE_URL = "http://localhost:8000/api/v1"

# 1. 创建知识库
kb_response = requests.post(f"{BASE_URL}/knowledge-bases/", json={
    "name": "技术文档库",
    "description": "存储技术文档",
    "chunk_size": 1000,
    "chunk_overlap": 200
})
kb_id = kb_response.json()["data"]["id"]

# 2. 上传文档
with open("document.txt", "rb") as f:
    doc_response = requests.post(f"{BASE_URL}/documents/upload", 
                               files={"file": f}, 
                               data={"kb_id": kb_id})

# 3. 创建对话
conv_response = requests.post(f"{BASE_URL}/conversations/", json={
    "title": "技术咨询",
    "kb_ids": [kb_id]
})
conv_id = conv_response.json()["data"]["id"]

# 4. 发送聊天消息
chat_response = requests.post(f"{BASE_URL}/conversations/{conv_id}/chat", json={
    "conversation_id": conv_id,
    "message": "请解释什么是FastAPI？",
    "use_rag": True,
    "top_k": 3
})
print(chat_response.json()["data"]["content"])
```

## ⚠️ 当前版本限制

### 简化实现的部分
1. **向量搜索**: 使用文本匹配作为临时方案，需要集成真正的向量搜索
2. **LLM集成**: 聊天功能为简化实现，需要接入实际LLM服务
3. **文件解析**: 只支持基础文本文件，复杂格式需要专门解析器
4. **用户认证**: 移除了用户管理功能，适用于内部使用

### 生产环境升级建议
1. 集成OpenAI或其他LLM服务
2. 使用真正的向量数据库（Pinecone、Weaviate等）
3. 添加用户认证和权限管理
4. 集成专业文档解析服务
5. 添加缓存和性能优化

## 🎉 总结

这个简化版RAG API具备以下优势：

✅ **开箱即用**: 基于RAGFlow设计，功能完整  
✅ **技术先进**: FastAPI + Supabase，性能优秀  
✅ **部署简单**: 环境变量配置，一键启动  
✅ **文档完善**: 自动生成API文档，便于开发  
✅ **扩展性强**: 模块化设计，易于功能扩展  

你可以基于这个基础版本，根据实际需求逐步添加更复杂的功能，如真正的向量搜索、LLM集成、用户认证等。
